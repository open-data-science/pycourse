# Условные конструкции, булева логика и сравнения

<!-- https://github.com/quantum-ods/qmlcourse/blob/master/qmlcourse/book/python/ru/python_l5.md -->

!!! info "Автор(ы)"

    - [Котенков Игорь](https://github.com/stalkermustang)

## Ветвление логики

В прошлых лекциях рассмотрели программы с линейной структурой: сначала выполнялась первая конструкция (например, объявление переменной), затем вторая (преобразование переменной или расчет по формуле), после – третья (`print` для вывода результатов). Можно сказать, что происходило последовательное исполнение команд, причем каждая инструкция выполнялась ^^обязательно^^. Но что делать, если хочется опираться на обстоятельства и принимать решения о том, выполнять одну часть кода или другую?

Допустим, по числу `x` нужно определить его абсолютную величину, то есть модуль. Программа должна напечатать значение переменной `x`, если `x > 0` или же величину `-x` в противном случае (`-(-5) = 5`). Эту логику можно записать следующим образом:

```python linenums="1"
x = -3  # попробуйте поменять значение переменной

if x > 0:
    print("Исходный x больше нуля")
    print(x)
else:
    print("Исходный x меньше или равен нулю")
    print(-x)
```
```bash
Исходный x меньше или равен нулю
3
```

В этой программе используется условная инструкция `if` (в переводе с английского _«если»_). `if` – это ключевое зарезервированное слово (так _нельзя назвать свою переменную_), указывающее на ^^условную конструкцию^^. После `if` следует указать вычислимое выражение, которое ^^можно проверить на истинность^^ (то есть можно сказать, правда это или нет). Общий вид конструкции следующий:

```python linenums="1"
if (Условие):
    <Блок инструкций 1>
else:
    <Блок инструкций 2>
```

`else` – тоже ключевое слово (в переводе – _«иначе»_). Таким образом, можно в голове придерживаться такой интерпретации: «^^если^^ условие верно (истинно), ^^то^^ выполни первый блок команд, ^^иначе^^ выполни второй блок».

Условная инструкция содержит как минимум ключевое слово `if` (единожды), затем может идти любое количество (включая ноль) блоков с условием `else if <условие>` (_иначе если_, то есть будет выполнена проверка нового условия в случае, если первая проверка в `if` не прошла, кратко `else if` записывается как `elif`), затем – опционально – конструкция `else`. Логика чтения и выполнения кода сохраняет порядок ^^сверху вниз^^. Как только одно из условий будет выполнено, выполнится соответствующая инструкция (или набор инструкций), а все последующие блоки будут проигнорированы. Это проиллюстрировано в коде:

```python linenums="1"
x = -3.8  # попробуйте поменять значение переменной

if x > 0:
    print("x больше нуля")
elif x < 0:  # можно написать "else if x < 0:"
    print("x меньше нуля")
else:
    print("x в точности равен нулю")
print("Такие дела!")
```
```bash
x меньше нуля
Такие дела!
```

Понятно, что `x` не может одновременно быть и больше нуля, и меньше (или равен ему). Среди всех трех `print`-блоков будет выполнен ^^только один^^. Если `x` действительно больше нуля, то второе условие (`x < 0`) даже не будет проверяться – `Python` сразу же перейдет к последней строке и выведет надпись «Такие дела!».

Чтобы лучше разобраться в том, как работает код, можно использовать ^^визуализаторы^^ – например, [такой](https://pythontutor.com/visualize.html). Прогоняйте через него весь код (даже в несколько строк) и сверяйте со своими ожиданиями от его работы.

## А что вообще такое эти ваши условия?

Выше было указано, что после конструкций `if`/`else if`/`elif` необходимо указать ^^условие^^, которое еще и должно быть истинным или ложным («правда или нет»). Давайте попробуем определить необходимый ^^тип^^ переменной.

```python linenums="1"
x = -3.8

condition_1 = x > 0
condition_2 = x < 0

print(condition_1, type(condition_1))
print(condition_2, type(condition_2))
```
```bash
False <class 'bool'>
True <class 'bool'>
```

Видно, что оба условия имеют один и тот же тип - `bool`, то есть `boolean`. По [определению](https://developer.mozilla.org/ru/docs/Glossary/Boolean):

!!! note "Замечание"

    Boolean (Булев, Логический тип данных) – примитивный тип данных в информатике, которые могут принимать ^^два возможных значения^^, иногда называемых истиной (True) и ложью (False).

Оказывается, что в коде выше были получены ^^ВСЕ^^ возможные варианты булевой переменной – это истина (`True`, пишется только с заглавной буквы) и ложь (`False`, аналогично). Никаких других значений быть для условия не может. Вот такой это простой тип данных.

## Способы получения `bool`

Какими вообще могут быть условия? Как с ними можно обращаться? Согласно [официальной документации](https://docs.python.org/3/library/stdtypes.html), в `Python` есть такие операторы сравнения:

<figure markdown>
  ![](./_static/operators_table.png)
  <figcaption>
  Все операции сравнения работают нативно (так же, как и в математике)
  </figcaption>
</figure>

```python linenums="1"
print(3.0 > 3)
print(3.0 == 3)
```
```bash
False
True
```

Здесь практически нечего рассматривать, операторы сравнения они и в `Python` операторы. Куда интереснее принцип ^^объединения различных условий в одно^^ – для создания комплексной логики.

Пусть стоит задача определения четверти точки по ее координатам на двумерной плоскости. Решение такой задачи может быть записано следующим образом:

```python linenums="1"
x = -3.6
y = 2.5432

if x > 0:
    if y > 0:
        # x > 0, y > 0
        print("Первая четверть")
    else:
        # x > 0, y < 0
        print("Четвертая четверть")
else:
    if y > 0:
        # x < 0, y > 0
        print("Вторая четверть")
    else:
        # x < 0, y < 0
        print("Третья четверть")
```
```bash
Вторая четверть
```

Пример показывает, что выполняемым блоком кода может быть любой блок `Python`, включая новый логический блок с `if-else` конструкцией. Однако его можно сократить с помощью ^^логических операторов^^ `and`, `or` и `not`. Это стандартные логические операторы [Булевой алгебры](https://ru.wikipedia.org/wiki/%D0%91%D1%83%D0%BB%D0%B5%D0%B2%D0%B0_%D0%B0%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0).

Логическое ^^И^^ является бинарным оператором (то есть оператором с двумя операндами: левым и правым) и имеет вид `and`. Оператор `and` возвращает `True` тогда и только тогда, когда ^^оба его операнда имеют значение^^ `True`.

Логическое ^^ИЛИ^^ является бинарным оператором и возвращает `True` тогда и только тогда, когда ^^хотя бы один операнд равен^^ `True`. Оператор «логическое ИЛИ» имеет вид `or`.

Логическое ^^НЕ^^ (отрицание) является унарным (то есть ^^с одним операндом^^) оператором и имеет вид `not`, за которым следует единственный операнд. Логическое НЕ возвращает `True`, ^^если операнд равен^^ `False` и ^^наоборот^^.

Эти правила необходимо запомнить для успешного создания сложных условий с целью разделения логики, заложенной в `Python`-коде.

Проиллюстрируем правила в коде на простых примерах. Обратите внимание на то, как можно объявлять `bool`-переменные – это не сложнее, чем создание целочисленного значения:

```python linenums="1"
true_value = True
false_value = False

# False потому, что один из операндов является False
some_value = true_value and false_value
print(some_value)

# True потому, что хотя бы один из операндов равен True
some_value = true_value or false_value
print(some_value)

# отрицание True (истины) есть False (ложь)
some_value = not true_value
print(some_value == false_value)

# пример сложного условия - порядок лучше в явном виде задавать скобками
hard_condition = (not true_value or false_value) or (true_value != false_value)
print(hard_condition)
```
```bash
False
True
True
True
```

Теперь попробуем их применить на приближенных к практике примерах:

```python linenums="1"
x = -3.6
y = 2.5432

if x > 0 and y > 0:  # конструкция заменяет два вложенных if
    print("Первая четверть")
elif x > 0 and y < 0:
    print("Четвертая четверть")
elif y > 0:
    print("Вторая четверть")
else:
    print("Третья четверть")

# определим, большое ли число x (в терминах модуля)
x_is_small = (x < 3) and (x > -3)
# число большое, если оно не маленькое (по модулю)
x_is_large = not x_is_small  # можно отрицать факт малости x

print('Is x small? ', x_is_small)
print('Is x large? ', x_is_large)

# так тоже можно писать - на манер неравенств в математике
another_x_is_small = -3 < x < 3
print(another_x_is_small)
print(another_x_is_small == x_is_small)
```
```bash
Вторая четверть
Is x small?  False
Is x large?  True
False
True
```

Так как вторая переменная `x_is_large` – это отрицание (`not`) первой (`x_is_small`), то они ^^никогда^^ не будут равны.

## Блоки кода и отступы

В примерах выше наверняка заметили упоминание термина «блок кода», а также откуда-то взявшиеся отступы после условий, и это не случайно. Во-первых, давайте признаем, что так условные конструкции (особенно вложенные!) читать куда легче, и глаза не разбегаются. Во-вторых, это особенность языка `Python` – здесь не используются скобки `{`, `}` для указания блоков, все форматирование происходит с помощью отступов. Отступы ^^всегда^^ добавляются в строки кода ^^после двоеточия^^.

Для выделения блока инструкций (строк кода, выполняющихся подряд при любых условиях), относящихся к инструкциям `if`, `else` или другим, изучаемым далее, в языке `Python` используются ^^отступы^^. Все инструкции, которые относятся к одному блоку, должны иметь ^^равную величину отступа^^, то есть одинаковое число ^^пробелов в начале строки^^. В качестве отступа [PEP 8](https://www.python.org/dev/peps/pep-0008/#tabs-or-spaces) рекомендует использовать ^^отступ в четыре пробела^^ и не рекомендует использовать символ табуляции. Если нужно сделать еще одно вложение блока инструкций, достаточно добавить еще четыре пробела (см. пример выше с поиском четверти на плоскости).

!!! tip "Совет"

    Хоть и не рекомендуется использовать символ табуляции для создания отступов, кнопка ++tab++ на вашей клавиатуре в `Jupyter`-ноутбуке (при курсоре, указывающим на начало строки кода) создаст отступ в четыре пробела. Пользуйтесь этим, чтобы не перегружать клавишу пробела лишними постукиваниями :).

## Что узнали из лекции

- Для задания логики выполнения кода и создания нелинейности используются ^^условные инструкции^^, поскольку они следуют некоторым условиям.
- Условная инструкция задается ключевым словом `if`, после которого может следовать несколько (от нуля) блоков `else if`/`elif`, и – опционально – в конце добавляется `else`, если ни один из блоков выше не сработал.
- Условия должны быть ^^булевого типа^^ (`bool`) и могут принимать ^^всего два значения^^ – `True` и `False`. Выполнится тот блок кода, который задан истинным (`True`) условием (и только первый!).
- Условные конструкции можно вкладывать друг в друга, а также объединять с помощью ^^логических операторов^^ `and`, `or` и `not`.
- ^^Блок кода^^ – это несколько подряд идущих команд, которые будут выполнены последовательно.
- Чтобы выделить блок кода после условия, используйте ^^отступы^^ – четыре пробела.
- Чтобы создать отступ в `Jupyter`, нужно нажать ++tab++ в начале строки кода.
